# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

X2Dgrid <- function(x1, x2) {
    .Call(`_bmms_X2Dgrid`, x1, x2)
}

rndpp_bern <- function(p) {
    .Call(`_bmms_rndpp_bern`, p)
}

split_struct_ratio <- function(prop_split, orig_split, p, param) {
    .Call(`_bmms_split_struct_ratio`, prop_split, orig_split, p, param)
}

bmms_setdiff <- function(x, y) {
    .Call(`_bmms_bmms_setdiff`, x, y)
}

rndpp_unif_int <- function(max) {
    .Call(`_bmms_rndpp_unif_int`, max)
}

rndpp_discrete <- function(probs) {
    .Call(`_bmms_rndpp_discrete`, probs)
}

rndpp_gamma <- function(alpha, beta) {
    .Call(`_bmms_rndpp_gamma`, alpha, beta)
}

rndpp_normal <- function(mean, sigma) {
    .Call(`_bmms_rndpp_normal`, mean, sigma)
}

rndpp_mvnormal <- function(n, mean, sigma) {
    .Call(`_bmms_rndpp_mvnormal`, n, mean, sigma)
}

col_eq_check <- function(A) {
    .Call(`_bmms_col_eq_check`, A)
}

col_sums <- function(matty) {
    .Call(`_bmms_col_sums`, matty)
}

single_split <- function(Jcoarse, where, p) {
    .Call(`_bmms_single_split`, Jcoarse, where, p)
}

multi_split <- function(Jcoarse, where, p) {
    .Call(`_bmms_multi_split`, Jcoarse, where, p)
}

exclude <- function(test, excl) {
    .Call(`_bmms_exclude`, test, excl)
}

splitsub_to_splitmask <- function(splits, p1, p2) {
    .Call(`_bmms_splitsub_to_splitmask`, splits, p1, p2)
}

splitmask_to_splitsub <- function(splitmask) {
    .Call(`_bmms_splitmask_to_splitsub`, splitmask)
}

row_intersection <- function(mat1, mat2) {
    .Call(`_bmms_row_intersection`, mat1, mat2)
}

row_difference <- function(mat1, mat2) {
    .Call(`_bmms_row_difference`, mat1, mat2)
}

splits_augmentation <- function(splits) {
    .Call(`_bmms_splits_augmentation`, splits)
}

splitsub_to_groupmask <- function(splits, p1, p2) {
    .Call(`_bmms_splitsub_to_groupmask`, splits, p1, p2)
}

mat_unique <- function(A) {
    .Call(`_bmms_mat_unique`, A)
}

mask_oneval <- function(A, mask, val) {
    .Call(`_bmms_mask_oneval`, A, mask, val)
}

mask_oneval_sum <- function(A, mask, val) {
    .Call(`_bmms_mask_oneval_sum`, A, mask, val)
}

mask_cube_slice <- function(C, slice, mask, val) {
    .Call(`_bmms_mask_cube_slice`, C, slice, mask, val)
}

mat_to_vec_by_region <- function(A, mask, unique_regions) {
    .Call(`_bmms_mat_to_vec_by_region`, A, mask, unique_regions)
}

cube_to_mat_by_region <- function(C, mask, unique_regions) {
    .Call(`_bmms_cube_to_mat_by_region`, C, mask, unique_regions)
}

unmask_vector <- function(beta, regions, mask) {
    .Call(`_bmms_unmask_vector`, beta, regions, mask)
}

load_splits <- function(maxlevs) {
    .Call(`_bmms_load_splits`, maxlevs)
}

merge_splits <- function(old_splits, new_splits) {
    .Call(`_bmms_merge_splits`, old_splits, new_splits)
}

cube_mean <- function(X, dim) {
    .Call(`_bmms_cube_mean`, X, dim)
}

cube_sum <- function(X, dim) {
    .Call(`_bmms_cube_sum`, X, dim)
}

number_availables <- function(splitmask_focus) {
    .Call(`_bmms_number_availables`, splitmask_focus)
}

index_to_subscript <- function(index, m) {
    .Call(`_bmms_index_to_subscript`, index, m)
}

soi <- function(y, X, splits, mask_forbid, lambda_splits, lambda_ridge, mcmc, burn, radius, max_stages, start_movinglev, partnum, save = TRUE, save_splitmask = TRUE) {
    .Call(`_bmms_soi`, y, X, splits, mask_forbid, lambda_splits, lambda_ridge, mcmc, burn, radius, max_stages, start_movinglev, partnum, save, save_splitmask)
}

soi_binary <- function(y, X, splits, mask_forbid, lambda_splits, lambda_ridge, mcmc, burn, radius, max_stages, start_movinglev, partnum, save = TRUE, save_splitmask = TRUE, fixsigma = FALSE) {
    .Call(`_bmms_soi_binary`, y, X, splits, mask_forbid, lambda_splits, lambda_ridge, mcmc, burn, radius, max_stages, start_movinglev, partnum, save, save_splitmask, fixsigma)
}

bvs <- function(y, X, prior, mcmc, g = -1.0, model_prior_par = 1.0, fixs = FALSE) {
    .Call(`_bmms_bvs`, y, X, prior, mcmc, g, model_prior_par, fixs)
}

ModularVS_export <- function(y, Xall, starting, MCMC, gg, ss, binary = FALSE) {
    .Call(`_bmms_ModularVS_export`, y, Xall, starting, MCMC, gg, ss, binary)
}

totsplit_prior_ratio <- function(tot_split_prop, tot_split_orig, norp, ss, lambda_prop) {
    .Call(`_bmms_totsplit_prior_ratio`, tot_split_prop, tot_split_orig, norp, ss, lambda_prop)
}

splitpar_prior <- function(x, tot_split, norp, ss) {
    .Call(`_bmms_splitpar_prior`, x, tot_split, norp, ss)
}

totstage_prior_ratio <- function(tot_stage_prop, tot_stage_orig, norp, curr_n_splits, direction) {
    .Call(`_bmms_totstage_prior_ratio`, tot_stage_prop, tot_stage_orig, norp, curr_n_splits, direction)
}

splits_truncate <- function(splits, k) {
    .Call(`_bmms_splits_truncate`, splits, k)
}

sof <- function(y, X, max_stages, mcmc = 100L, burn = 50L, lambda = 5.0, silent = TRUE) {
    .Call(`_bmms_sof`, y, X, max_stages, mcmc, burn, lambda, silent)
}

sofk <- function(y, X, start_splits, mcmc = 100L, burn = 50L, lambda = 5.0, ii = 0L, ll = 0L, silent = TRUE) {
    .Call(`_bmms_sofk`, y, X, start_splits, mcmc, burn, lambda, ii, ll, silent)
}

sofk_binary <- function(y, X, start_splits, mcmc = 100L, burn = 50L, lambda = 5.0, ii = 0L, ll = 0L, silent = TRUE) {
    .Call(`_bmms_sofk_binary`, y, X, start_splits, mcmc, burn, lambda, ii, ll, silent)
}

bmms_base <- function(y, X, g, mcmc, burn, splits, silent = TRUE) {
    .Call(`_bmms_bmms_base`, y, X, g, mcmc, burn, splits, silent)
}

pnorm01_vec <- function(x, lower = 1L, logged = 0L) {
    .Call(`_bmms_pnorm01_vec`, x, lower, logged)
}

qnorm01_vec <- function(x, lower = 1L, logged = 0L) {
    .Call(`_bmms_qnorm01_vec`, x, lower, logged)
}

log1p_vec <- function(x) {
    .Call(`_bmms_log1p_vec`, x)
}

usetdiff <- function(x, y) {
    .Call(`_bmms_usetdiff`, x, y)
}

lnNpr_cpp <- function(a, b) {
    .Call(`_bmms_lnNpr_cpp`, a, b)
}

cholperm_cpp <- function(Sig, l, u) {
    .Call(`_bmms_cholperm_cpp`, Sig, l, u)
}

gradpsi_cpp <- function(y, L, l, u, grad) {
    .Call(`_bmms_gradpsi_cpp`, y, L, l, u, grad)
}

armasolve <- function(A, grad) {
    .Call(`_bmms_armasolve`, A, grad)
}

nleq <- function(l, u, L) {
    .Call(`_bmms_nleq`, l, u, L)
}

ntail_cpp <- function(l, u) {
    .Call(`_bmms_ntail_cpp`, l, u)
}

trnd_cpp <- function(l, u) {
    .Call(`_bmms_trnd_cpp`, l, u)
}

tn_cpp <- function(l, u) {
    .Call(`_bmms_tn_cpp`, l, u)
}

trandn_cpp <- function(l, u) {
    .Call(`_bmms_trandn_cpp`, l, u)
}

mvnrnd_cpp <- function(n, L, l, u, mu, logpr) {
    .Call(`_bmms_mvnrnd_cpp`, n, L, l, u, mu, logpr)
}

psy_cpp <- function(x, L, l, u, mu) {
    .Call(`_bmms_psy_cpp`, x, L, l, u, mu)
}

mvrandn_cpp <- function(l_in, u_in, Sig, n) {
    .Call(`_bmms_mvrandn_cpp`, l_in, u_in, Sig, n)
}

mvtruncnormal <- function(mean, l_in, u_in, Sig, n) {
    .Call(`_bmms_mvtruncnormal`, mean, l_in, u_in, Sig, n)
}

mvtruncnormal_eye1 <- function(mean, l_in, u_in) {
    .Call(`_bmms_mvtruncnormal_eye1`, mean, l_in, u_in)
}

rndpp_mvnormal2 <- function(n, mu, sigma) {
    .Call(`_bmms_rndpp_mvnormal2`, n, mu, sigma)
}

rndpp_mvnormalnew <- function(n, mean, sigma) {
    .Call(`_bmms_rndpp_mvnormalnew`, n, mean, sigma)
}

get_S <- function(y, X) {
    .Call(`_bmms_get_S`, y, X)
}

get_Ddiag <- function(Sigma, S) {
    .Call(`_bmms_get_Ddiag`, Sigma, S)
}

diag_default_mult <- function(A, D) {
    .Call(`_bmms_diag_default_mult`, A, D)
}

diag_custom_mult <- function(A, D) {
    .Call(`_bmms_diag_custom_mult`, A, D)
}

beta_post_sample <- function(mu, Sigma, S, Ddiag, sample_size = 1L) {
    .Call(`_bmms_beta_post_sample`, mu, Sigma, S, Ddiag, sample_size)
}

