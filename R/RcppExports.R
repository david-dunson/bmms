# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

load_splits <- function(maxlevs, sname) {
    .Call('_bmms_load_splits', PACKAGE = 'bmms', maxlevs, sname)
}

cube_mean <- function(X, dim) {
    .Call('_bmms_cube_mean', PACKAGE = 'bmms', X, dim)
}

cube_sum <- function(X, dim) {
    .Call('_bmms_cube_sum', PACKAGE = 'bmms', X, dim)
}

#' Vector index to matrix subscripts
#' 
#' Get matrix subscripts from corresponding vector indices (both start from 0).
#' This is a utility function using Armadillo's ind2sub function.
#' @param index a vector of indices
#' @param m a matrix (only its size is important)
#' @export
index_to_subscript <- function(index, m) {
    .Call('_bmms_index_to_subscript', PACKAGE = 'bmms', index, m)
}

soi_cpp <- function(y, X, splits, mask_forbid, lambda_centers, lambda_ridge, mcmc, burn, radius = 2L, start_movinglev = 0L, partnum = 0L, save = TRUE, save_splitmask = FALSE) {
    .Call('_bmms_soi_cpp', PACKAGE = 'bmms', y, X, splits, mask_forbid, lambda_centers, lambda_ridge, mcmc, burn, radius, start_movinglev, partnum, save, save_splitmask)
}

soi_binary_cpp <- function(y, X, centers, mask_forbid, lambda_centers, lambda_ridge, mcmc, burn, radius = 2L, start_movinglev = 0L, partnum = 0L, save = TRUE, save_splitmask = TRUE, fixsigma = FALSE) {
    .Call('_bmms_soi_binary_cpp', PACKAGE = 'bmms', y, X, centers, mask_forbid, lambda_centers, lambda_ridge, mcmc, burn, radius, start_movinglev, partnum, save, save_splitmask, fixsigma)
}

bvs <- function(y, X, prior, mcmc, g = -1.0, model_prior_par = 1.0, fixs = FALSE) {
    .Call('_bmms_bvs', PACKAGE = 'bmms', y, X, prior, mcmc, g, model_prior_par, fixs)
}

momscaleBVS <- function(y, Xall, starting, MCMC, gg, ss, binary = FALSE) {
    .Call('_bmms_momscaleBVS', PACKAGE = 'bmms', y, Xall, starting, MCMC, gg, ss, binary)
}

sof <- function(y, X, max_stages, mcmc = 100L, burn = 50L, lambda = 5.0, silent = TRUE) {
    .Call('_bmms_sof', PACKAGE = 'bmms', y, X, max_stages, mcmc, burn, lambda, silent)
}

sofk <- function(y, X, start_splits, mcmc = 100L, burn = 50L, lambda = 5.0, ii = 0L, ll = 0L, silent = TRUE) {
    .Call('_bmms_sofk', PACKAGE = 'bmms', y, X, start_splits, mcmc, burn, lambda, ii, ll, silent)
}

sofk_binary <- function(y, X, start_splits, mcmc = 100L, burn = 50L, lambda = 5.0, ii = 0L, ll = 0L, silent = TRUE) {
    .Call('_bmms_sofk_binary', PACKAGE = 'bmms', y, X, start_splits, mcmc, burn, lambda, ii, ll, silent)
}

bmms_base <- function(y, X, g, mcmc, burn, splits, silent = TRUE) {
    .Call('_bmms_bmms_base', PACKAGE = 'bmms', y, X, g, mcmc, burn, splits, silent)
}

mvtruncnormal <- function(mean, l_in, u_in, Sig, n) {
    .Call('_bmms_mvtruncnormal', PACKAGE = 'bmms', mean, l_in, u_in, Sig, n)
}

mvtruncnormal_eye1 <- function(mean, l_in, u_in) {
    .Call('_bmms_mvtruncnormal_eye1', PACKAGE = 'bmms', mean, l_in, u_in)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_bmms_RcppExport_registerCCallable', PACKAGE = 'bmms')
})
